<?php
namespace Raudius\Luar\Interpreter;

use Raudius\Luar\Interpreter\LuarObject\Literal;
use Raudius\Luar\Interpreter\Tokens\FuncBody;
use Raudius\Luar\Interpreter\Tokens\FuncName;
use Raudius\Luar\Parser\Context;

class LuarStatementVisitor extends LuarExpressionVisitor {
	public function visitStatIf(Context\StatIfContext $context) {
		$conditions = $context->exp();
		$blocks = $context->block();
		if (!$conditions || !$blocks) {
			throw new RuntimeException('Could not parse if statement, missing condition or block.');
		}

		$conditions = is_array($conditions) ? $conditions : [$conditions];
		$blocks = is_array($blocks) ? $blocks : [$blocks];
		foreach ($conditions as $i => $condition) {
			if ($this->visitExp($condition)->getValue()) {
				return $this->visitBlock($blocks[$i]);
			}
		}

		// Else
		if (count($blocks) > count($conditions)) {
			return $this->visitBlock(end($blocks));
		}

		return null;
	}

	public function visitStatFunctionDeclare(Context\StatFunctionDeclareContext $context) {
		$funcName = $this->visitFuncname($context->funcname());
		$funcBody = $this->visitFuncbody($context->funcbody());

		$scope = $this->interpreter->getRoot()->gets($funcName->getChain());
		if (!$scope instanceof Scope) {
			throw new RuntimeException("Attempted to declare function in non-scopable context.", $context);
		}

		$scope->assign($funcName->getName(), $funcBody->asInvokable($this->interpreter));

		return parent::visitStatFunctionDeclare($context); // TODO: Change the autogenerated stub
	}

	public function visitFuncname(Context\FuncnameContext $context): FuncName {
		$names = $this->getNameChain($context);

		$methodContext = $context->funcname_method();
		$method = $methodContext ? $methodContext->NAME()->getText() : null;

		return new FuncName($names, $method);
	}

	public function visitFuncbody(Context\FuncbodyContext $context) {
		$namelist = $context->parlist() ? $context->parlist()->namelist() : null;
		$parameters = $namelist ? $this->getNameChain($namelist) : [];

		if ($context->parlist() && $context->parlist()->elipsis()) {
			$parameters[] = '...';
		}

		return new FuncBody($parameters, $context->block());
	}

	public function visitStatAssign(Context\StatAssignContext $context) {
		$varlist = $this->visitVarlist($context->varlist(), $this->interpreter->getRoot());
		$explist = $this->visitExplist($context->explist());

		foreach ($varlist as $i => $var) {
			$exp = $explist[$i] ?? new Literal(null);
			$var->setValue($exp);
		}
	}

	public function visitStatBreak(Context\StatBreakContext $context) {
		$this->interpreter->getScope()->setExit(Scope::EXIT_BREAK);
	}

	public function visitLaststat(Context\LaststatContext $context): Scope {
		$firstLetter = $context->getText()[0];
		$scope = $this->interpreter->getScope();

		switch ($firstLetter) {
			case 'r': // return
				$explist = $context->explist() ? $this->visitExplist($context->explist()) : null;
				$scope->setExit(Scope::EXIT_RETURN, $explist);
				break;
			case 'b': // break
				$scope->setExit(Scope::EXIT_BREAK);
				break;
			case 'c': // continue
				$scope->setExit(Scope::EXIT_CONTINUE);
				break;
		}

		return $scope;
	}

	public function visitStatWhile(Context\StatWhileContext $context) {
		$expContext = $context->exp();
		$blockContext = $context->block();

		if (!$expContext || !$blockContext) {
			throw new RuntimeException('[INTERNAL ERROR] Could not parse while loop', $context);
		}

		while ($this->visitExp($expContext)->getValue()) {
			$scope = $this->visitBlock($blockContext, Scope::EXIT_EXPECT_BREAK_CONTINUE);

			if ($scope->getExit() === Scope::EXIT_BREAK || $scope->getExit() === Scope::EXIT_RETURN) {
				break;
			}
		}
	}
}
